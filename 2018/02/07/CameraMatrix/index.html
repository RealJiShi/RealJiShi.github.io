<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>coordinate transformation | technician tech</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Computer Graphics" />
  
  
  
  
  <meta name="description" content="1&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&amp;gt;&amp;lt;/script&amp;gt; 2018/1/18 17:13:48  Coordinate Transformation: From Euler to Quaternion Intr">
<meta name="keywords" content="Computer Graphics">
<meta property="og:type" content="article">
<meta property="og:title" content="Coordinate Transformation">
<meta property="og:url" content="http://yoursite.com/2018/02/07/CameraMatrix/index.html">
<meta property="og:site_name" content="technician tech">
<meta property="og:description" content="1&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&amp;gt;&amp;lt;/script&amp;gt; 2018/1/18 17:13:48  Coordinate Transformation: From Euler to Quaternion Intr">
<meta property="og:image" content="https://i.imgur.com/KJYDz4Z.png">
<meta property="og:image" content="https://i.imgur.com/m9n5CmI.png">
<meta property="og:image" content="c:/Users/meyan/Desktop/quaternion/camera_pitch.png">
<meta property="og:image" content="https://i.imgur.com/gXwEqBa.png">
<meta property="og:image" content="c:/Users/meyan/Desktop/quaternion/3.png">
<meta property="og:image" content="c:/Users/meyan/Desktop/quaternion/4.png">
<meta property="og:image" content="c:/Users/meyan/Desktop/quaternion/5.png">
<meta property="og:updated_time" content="2018-02-22T01:53:30.650Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coordinate Transformation">
<meta name="twitter:description" content="1&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&amp;gt;&amp;lt;/script&amp;gt; 2018/1/18 17:13:48  Coordinate Transformation: From Euler to Quaternion Intr">
<meta name="twitter:image" content="https://i.imgur.com/KJYDz4Z.png">
  
    <link rel="alternate" href="/atom.xml" title="technician tech" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">Home</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">Archives</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">Categories</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">Tags</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">About</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-CameraMatrix" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Coordinate Transformation
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/02/07/CameraMatrix/" class="article-date">
	  <time datetime="2018-02-07T11:14:03.000Z" itemprop="datePublished">2018-02-07</time>
	</a>

      
      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		PV:<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2018/1/18 17:13:48</p>
<hr>
<h1 id="Coordinate-Transformation-From-Euler-to-Quaternion"><a href="#Coordinate-Transformation-From-Euler-to-Quaternion" class="headerlink" title="Coordinate Transformation: From Euler to Quaternion"></a>Coordinate Transformation: From Euler to Quaternion</h1><ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Linear-transformation">Linear Transformation</a></li>
<li><a href="#Scale-transformation">Scale Transformation</a></li>
<li><a href="#Euler-transformation">Euler Rotation</a><ul>
<li><a href="#Rotation-matrix">Rotation Matrix</a></li>
<li><a href="#Euler-Camera">Euler Camera</a></li>
<li><a href="#Euler-Drawback">Euler Drawback</a></li>
</ul>
</li>
<li><a href="#Quaternion-rotation">Quaternion Rotation</a><ul>
<li><a href="#complex">Complex</a></li>
<li><a href="#Quaternion-theory">Quaternion Theory</a></li>
<li><a href="#Quaternion-camera">Quaternion Camera</a></li>
</ul>
</li>
<li><a href="#Appendix-reference">Appendix &amp; Reference</a></li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>坐标变换是将三维空间的一组向量从一个坐标空间变换到另一个坐标空间，其中可分为线性、比例、平移和旋转变换。我们这里使用<em>OpenGL</em>实现文中算法，用<em>GLM</em>库来组织数据，并且使用<em>GLFW</em>作为<em>OpenGL</em>的窗口，日后我们会升级为<em>Qt</em>。</p>
<h2 id="Linear-Transformation"><a href="#Linear-Transformation" class="headerlink" title="Linear Transformation"></a>Linear Transformation</h2><p>线性变换很简单，可以表示为：<br>$$<br>\begin{equation}<br>\begin{bmatrix} x’\ y’\ z’\ \end{bmatrix} =<br>\begin{bmatrix} U<em>{1}  &amp; V</em>{1} &amp; W<em>{1} \ U</em>{2}  &amp; V<em>{2} &amp; W</em>{2} \ U<em>{3}  &amp; V</em>{3} &amp; W<em>{3} \ \end{bmatrix}<br>\begin{bmatrix} x\ y\ z\ \end{bmatrix} +<br>\begin{bmatrix} T</em>{1}\ T<em>{2}\ T</em>{3}\ \end{bmatrix}<br>\tag{1}<br>\end{equation}<br>$$<br>有一个比较重要的概念是正交矩阵，其是由n个正交的基向量构成。其中：<br>$$<br>M^{-1} = M^{T} \tag{2}<br>$$<br>(2)式可以简化正交矩阵的求逆， 将其转化为矩阵的转秩。</p>
<h2 id="Scale-Transformation"><a href="#Scale-Transformation" class="headerlink" title="Scale Transformation"></a>Scale Transformation</h2><p>比例变换也很简单：<br>$$<br>\begin{equation}<br>\begin{bmatrix} x’ \ y’ \ z’\ \end{bmatrix} =<br>\begin{bmatrix} a &amp; &amp; \ &amp; b &amp; \ &amp; &amp; c \ \end{bmatrix}<br>\begin{bmatrix} x \ y \ z\ \end{bmatrix}<br>\tag{3}<br>\end{equation}<br>$$<br>如果a,b,c相等为等比例缩放。</p>
<h2 id="Euler-Rotation"><a href="#Euler-Rotation" class="headerlink" title="Euler Rotation"></a>Euler Rotation</h2><h3 id="Rotation-Matrix"><a href="#Rotation-Matrix" class="headerlink" title="Rotation Matrix"></a>Rotation Matrix</h3><p>通过一个$3 \times 3$矩阵，我们可以将一个坐标绕x，y，z旋转$\theta$角。</p>
<p>首先讨论二维空间的旋转公式，对于<em>x-y</em>平面中的一个二维向量，将x和y坐标交换，并且将交换后的x坐标取反，就实现了向量$\overrightarrow{P}$的$90^{\circ}$逆时针旋转，即向量$\overrightarrow{Q}$。$\overrightarrow{P}$与$\overrightarrow{Q}$构成一对二维空间正交基。现有一向量$\overrightarrow{P’}$，是$\overrightarrow{P}$旋转$\theta$所得，那么有：<br>$$<br>\begin{equation}<br>P’ = Pcos\theta + Qsin\theta<br>\tag{4}<br>\end{equation}<br>$$<br>展开：<br>$$<br>\begin{align}<br>P<em>{x}’ = xcos\theta - ysin\theta \<br>P</em>{y}’ = xcos\theta + ysin\theta<br>\end{align}<br>$$<br>展开成矩阵的形式：<br>$$<br>\begin{equation}<br>\begin{bmatrix} P<em>{x}’ \ P</em>{y}’\end{bmatrix} =<br>\begin{bmatrix} cos\theta &amp; -sin\theta \ sin\theta &amp; cos\theta \end{bmatrix}<br>\end{equation}<br>$$<br>下面是分别绕x,y,z轴的旋转矩阵：<br>$$<br>\begin{equation}<br>R_{x}(\theta) =<br>\begin{bmatrix} 1 &amp; 0 &amp; 0 \ 0 &amp; cos\theta &amp; -sin\theta \ 0 &amp; sin\theta &amp; cos\theta \end{bmatrix}<br>\tag{5}<br>\end{equation}<br>$$</p>
<p>$$<br>\begin{equation}<br>R_{y}(\theta) =<br>\begin{bmatrix} cos\theta &amp; 0 &amp; sin\theta \ 0 &amp; 1 &amp; 0 \ -sin\theta &amp; 0 &amp; cos\theta \end{bmatrix}<br>\tag{6}<br>\end{equation}<br>$$</p>
<p>$$<br>\begin{equation}<br>R_{z}(\theta) =<br>\begin{bmatrix} cos\theta &amp; -sin\theta &amp; 0 \ sin\theta &amp; cos\theta &amp; 0 \ 0 &amp; 0 &amp; 1 \end{bmatrix}<br>\tag{7}<br>\end{equation}<br>$$</p>
<h4 id="Rotate-with-arbitrary-axis"><a href="#Rotate-with-arbitrary-axis" class="headerlink" title="Rotate with arbitrary axis"></a>Rotate with arbitrary axis</h4><p><em>关于任意轴的旋转可以省略，但是这一小节在四元数的证明中很有用。</em></p>
<p>将向量$\overrightarrow{P}$绕任意轴旋转$\theta$角，单位向量$\overrightarrow{A}$表示一个旋转轴，那么向量$\overrightarrow{P}$可分解为与向量$\overrightarrow{A}$平行和垂直的分量。由于与向量$\overrightarrow{A}$平行的分量在旋转过程不变，那么问题就转化为向量$\overrightarrow{P}$与向量$\overrightarrow{A}$垂直分量的旋转问题。<br>首先，将向量$\overrightarrow{P}$在向量$\overrightarrow{A}$的投影与垂直分量表示为：<br>$$<br>\begin{align}<br>proj<em>{A}P&amp; = (A \cdot P)A \<br>perp</em>{A}P &amp;= P - (A \cdot P)A<br>\end{align}<br>$$<br>我们知道向量$\overrightarrow{P}$的垂直分量绕$\overrightarrow{A}$的旋转是在向量$\overrightarrow{A}$垂直平面内，结合我们之前二维空间旋转矩阵的证明公式，需要找到一个逆时针旋转$90^\circ$的向量用以构成一对正交基。这个向量很容易找到，即向量$\overrightarrow{A}$与向量$\overrightarrow{P}$的叉乘。则将垂直分量旋转$\theta$：<br>$$<br>[P - (A \cdot P)A]cos\theta + (A \times P)sin\theta<br>$$<br>加上水平投影分量得$\overrightarrow{P}$绕$\overrightarrow{A}$旋转$\theta$的解：<br>$$<br>\begin{equation}<br>P’ = Pcos\theta + (A \times P)sin\theta + (A \cdot P)A(1 - cos\theta)<br>\tag{8}<br>\end{equation}<br>$$</p>
<h3 id="Euler-Camera"><a href="#Euler-Camera" class="headerlink" title="Euler Camera"></a>Euler Camera</h3><p>其实在<em>OpenGL</em>中没有<strong>Camera</strong>的概念，但是通常的做法是反方向移动场景中所有物体来模拟出摄像机的视角，产生出一种摄像机在移动而非场景移动。</p>
<p>其实对于摄像机（即观察空间），我们的目标是找到一个坐标系可以将场景中所有的物体变换到此空间中。那么我们的目标就是找到一组正交基，构成这样一个摄像机空间。具体来说要定义一个摄像机，我们需要它在世界空间中的位置、观察方向、一个指向它右侧的向量和一个指向它上方的向量，如想图所示：</p>
<p><img src="https://i.imgur.com/KJYDz4Z.png" alt=""></p>
<h4 id="摄像机位置"><a href="#摄像机位置" class="headerlink" title="摄像机位置"></a>摄像机位置</h4><p>摄像机的位置非常简单，用代码我们可以表示为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos = glm::vec3( <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span> );</span><br></pre></td></tr></table></figure>
<h4 id="摄像机方向"><a href="#摄像机方向" class="headerlink" title="摄像机方向"></a>摄像机方向</h4><p>摄像机的方向是相机位置减去目标位置所得的向量，指向相机z轴正方向。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraDirection = glm::normalize( cameraPos - cameraTarget );</span><br></pre></td></tr></table></figure>
<h4 id="右轴"><a href="#右轴" class="headerlink" title="右轴"></a>右轴</h4><p>右向量表示摄像机x轴的正方向。可以观察到（下文会有描述），<strong>因为在二维屏幕上，我们只能对相机进行俯仰(pitch)与偏航(yaw)，所以其上轴只能在y平面上</strong>。所以这里我们先定义一个上向量$(0,1,0)$，接着将上向量与摄像机方向做叉乘，就得到了右轴：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);</span><br><span class="line">glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));</span><br></pre></td></tr></table></figure>
<h4 id="上轴"><a href="#上轴" class="headerlink" title="上轴"></a>上轴</h4><p>上轴现在就很好计算了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraUp = glm::normalize(glm::cross(cameraDirection, cameraRight));</span><br></pre></td></tr></table></figure>
<p>实际上，求出这几个方向的方法叫做<strong>Gram-Schmidt Process</strong>，具体可以参考<a href="https://item.jd.com/11974448.html" target="_blank" rel="noopener">3D游戏与计算机图形学中的数学方法</a>。</p>
<h4 id="Look-at-Matrix"><a href="#Look-at-Matrix" class="headerlink" title="Look-at Matrix"></a>Look-at Matrix</h4><p>现在相机坐标系是相对于世界坐标系的。那么我们对上面的向量做逆变换，就可以将场景变换到相机坐标系中了。这里我们就得到了一个LookAt矩阵：<br>$$<br>\begin{equation}<br>LookAt =<br>\begin{bmatrix} R<em>{x} &amp; R</em>{y} &amp; R<em>{z} &amp; 0\ U</em>{x} &amp; U<em>{y} &amp; U</em>{z} &amp; 0\ D<em>{x} &amp; D</em>{y} &amp; D<em>{z} &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1\ \end{bmatrix} *<br>\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; -P</em>{x} \ 0 &amp; 1 &amp; 0 &amp; -P<em>{y} \  0 &amp; 0 &amp; 1 &amp; -P</em>{z} \  0 &amp; 0 &amp; 0 &amp; 1 \ \end{bmatrix}<br>\end{equation}<br>$$<br>这里，对于相机坐标位置向量所构成的矩阵求逆，因为其是正交矩阵，所以相当于对该矩阵求转秩。同时将世界平移到与我们自身移动相反方向就可以将世界坐标变换到观察空间中。    </p>
<p><em>GLM</em>已经提供了相关的实现，我们只需要定义一个相机位置，目标位置和世界空间中的上向量，<em>GLM</em>就会创建一个LookAt矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;  </span></span></span><br><span class="line"><span class="comment">// glm::dmat4 glm::lookAt(</span></span><br><span class="line"><span class="comment">//     glm::dvec3 const &amp; eye,</span></span><br><span class="line"><span class="comment">//     glm::dvec3 const &amp; center,</span></span><br><span class="line"><span class="comment">//     glm::dvec3 const &amp; up);</span></span><br><span class="line"></span><br><span class="line">glm::mat4 view = glm::lookAt( glm::vec3( <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span> ),</span><br><span class="line">                              glm::vec3( <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> ),</span><br><span class="line">                              glm::vec3( <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span> ) );</span><br></pre></td></tr></table></figure>
<h4 id="自由移动"><a href="#自由移动" class="headerlink" title="自由移动"></a>自由移动</h4><p>如果想让相机进行平移运动，那么要先定义一些摄像机变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos = glm::vec3( <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span> );</span><br><span class="line">glm::vec3 cameraFront = glm::vec3( <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span> ); <span class="comment">// unit vector</span></span><br><span class="line">glm::vec3 cameraUp = glm::vec3( <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span> ); <span class="comment">// unit vector</span></span><br></pre></td></tr></table></figure>
<p>那么现在LookAt函数变成了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view = glm::lookAt( cameraPos, cameraPos + cameraFront, cameraUp );</span><br></pre></td></tr></table></figure>
<p>那么我们可以为<em>GLFW</em>的键盘输入定义一个<code>processInput</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> cameraSpeed = <span class="number">0.05f</span>;</span><br><span class="line">	<span class="keyword">if</span> ( glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS ) &#123;</span><br><span class="line">	    cameraPos += cameraSpeed * cameraFront;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS ) &#123;</span><br><span class="line">	    cameraPos -= cameraSpeed * cameraFront;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS ) &#123;</span><br><span class="line">	    cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS ) &#123;</span><br><span class="line">	    cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就实现了一个简单相机的平移。</p>
<h5 id="移动速度"><a href="#移动速度" class="headerlink" title="移动速度"></a>移动速度</h5><p>目前我们的移动速度是个常量。理论上没有什么问题，但是实际情况下根据处理器的能力不同，有些人可能会比其他人每秒绘制更多帧，也就是以更高的频率调用<code>processInput</code>函数。结果就是，根据配置的不同，有些人可能移动很快，而有些人会移动很慢。当发布程序的时候，必须确保它在所有硬件上移动速度都一样。<br>图形程序和游戏通常会追踪一个时间差$\delta$变量，它存储了渲染上一帧所用的时间。我们把所有速度都去乘$\delta(t)$值，结果就是，如果$\delta(t)$很大，就意味着上一帧的渲染花了更多时间，所以这一帧的速度需要变得更高去平衡渲染所花去的时间。使用这种方法是，无论计算机快慢，摄像机的速度都会平衡，这样每个用户的体验就是一样的了。</p>
<p>我们可以追踪两个全局变量来计算出$\delta(t)$值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> deltaTime = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> lastFrame = <span class="number">0.0f</span>;</span><br></pre></td></tr></table></figure>
<p>在每一帧中我们计算出新的deltaTime以备后用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> currentFrame = glfwGetTime();</span><br><span class="line">deltaTime = currentFrame - lastFrame;</span><br><span class="line">lastFrame = currentFrame;</span><br></pre></td></tr></table></figure>
<p>这样就可以将速度考虑就去了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> cameraSpeed = <span class="number">2.5f</span> * deltaTime;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="视角移动"><a href="#视角移动" class="headerlink" title="视角移动"></a>视角移动</h4><p>在视角移动中，通常使用欧拉角(Euler Angle)表示3D空间中任何旋转的三个值，分别是俯仰角(Pitch)、偏航角(Yaw)、滚转角(Roll)，如下图所示：</p>
<p><img src="https://i.imgur.com/m9n5CmI.png" alt=""></p>
<p>因为我们是在二维屏幕空间中操作摄像机，我们这里只关心俯仰角和偏航角，这里我们先从俯仰角开始：</p>
<p><img src="C:\Users\meyan\Desktop\quaternion\camera_pitch.png" alt="camera_pitch"></p>
<p><em>direction代表摄像机的前轴(Front)</em></p>
<p>从图中我们可以得倒：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">direction.y = <span class="built_in">sin</span>(glm::radians(pitch));</span><br><span class="line"><span class="comment">// x and z should be changed too</span></span><br><span class="line">direction.x = <span class="built_in">cos</span>(glm::radians(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::radians(pitch));</span><br></pre></td></tr></table></figure>
<p><em><code>direction.x</code>的变化是因为俯仰是针对于原点的俯仰，而非绕x轴俯仰</em>。</p>
<p>对于偏航角：</p>
<p><img src="https://i.imgur.com/gXwEqBa.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">direction.x = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">cos</span>(glm::radians(yaw));</span><br><span class="line">direction.y = <span class="built_in">sin</span>(glm::radians(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">sin</span>(glm::radians(yaw));</span><br></pre></td></tr></table></figure>
<p>到此为止，我们就可以创建一个摄像机类了，你可以在附件中找到我们想要的<a href="#Appendix-reference"><code>EulerCamera</code></a>。</p>
<h3 id="Euler-Drawback"><a href="#Euler-Drawback" class="headerlink" title="Euler Drawback"></a>Euler Drawback</h3><p>使用欧拉角很容易引起的问题是<a href="https://zh.wikipedia.org/wiki/%E7%92%B0%E6%9E%B6%E9%8E%96%E5%AE%9A" target="_blank" rel="noopener">万向锁</a>. 这里有个<a href="http://v.youku.com/v_show/id_XMTQyNTQxMjc2NA==.html" target="_blank" rel="noopener">视频</a>详细的讲解了产生万向锁的原理。</p>
<p>简单来说，万向锁的产生是因为旋转时存在了父子旋转关系，比如a轴是b、c的父轴，那么a轴的旋转会带动b、c轴进行旋转，当出现了90度的旋转时，那么就会导致两个轴重合，这时就出现了万向锁。</p>
<p>对于我们上文中讲到的相机系统，他们的父子结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x-&gt; y,z</span><br><span class="line">   y-&gt; z</span><br></pre></td></tr></table></figure>
<p>如果我们绕着上轴旋转$90^\circ$，那么z轴就会与x轴重合，那么再旋转z轴就没有任何的意义了，永远不会发生滚转。</p>
<h2 id="Quaternion-Rotation"><a href="#Quaternion-Rotation" class="headerlink" title="Quaternion Rotation"></a>Quaternion Rotation</h2><h3 id="Complex"><a href="#Complex" class="headerlink" title="Complex"></a>Complex</h3><p>在我们学习四元数之前，我们先来了解一下四元数的起源–<strong>复数</strong>。复数系统引入了一个新的集合–<strong>虚数</strong>，其实为了解决一些特定无解的方程：<br>$$<br>\begin{equation}<br>x^{2} + 1 = 0<br>\end{equation}<br>$$<br>任意实数的平方都是非负数，为了求解上面的方程一个新的术语就发明了，他就是虚数：<br>$$<br>i^{2} = -1<br>$$<br>复数的集合是一个实数和一个虚数的和：<br>$$<br>z = a + bi \quad a,b \in R, i^2 = -1<br>\tag{9}<br>$$<br><em>复数有很多的数学概念，具体的请查详细资料，这里不再累述。</em></p>
<h4 id="二维空间上的旋转"><a href="#二维空间上的旋转" class="headerlink" title="二维空间上的旋转"></a>二维空间上的旋转</h4><p>你可能在数学中见过类似的模式，但是是以(x,y,-x,-y,x…)的形式，这是2D笛卡尔平面对一个点逆时针旋转$90^\circ$生成的；(x,-y,-x,y,x…)则是在2D笛卡尔平面对一个点顺时针$90^\circ$生成的。</p>
<p><img src="C:\Users\meyan\Desktop\quaternion\3.png" alt="3"></p>
<p>我们也能够把复数映射到一个2D网格平面–复数平面，只需要将实数映射到横轴、虚数映射到纵轴即可：</p>
<p><img src="C:\Users\meyan\Desktop\quaternion\4.png" alt="4"></p>
<p>现在我们随机在复数平面上取一个点：<br>$$<br>p = 2 + i<br>$$<br>q,r,s,t分别是每次递乘i的结果：<br>$$<br>\begin{align}<br>q&amp;=-1+2i \<br>r&amp;=-2-i \<br>s&amp;=1-2i \<br>t&amp;=2+i \<br>\end{align}<br>$$<br><img src="C:\Users\meyan\Desktop\quaternion\5.png" alt="5"></p>
<p>所以我们可以在复数平面上进行任意角度的旋转：<br>$$<br>\begin{equation}<br>q=cos\theta + isin\theta<br>\tag{10}<br>\end{equation}<br>$$</p>
<h3 id="Quaternion-Theory"><a href="#Quaternion-Theory" class="headerlink" title="Quaternion Theory"></a>Quaternion Theory</h3><p>了解了复数系统和复数平面后，我们可以额外增加2个虚数到我们的复数系统，从而把这些概念扩展到3维空间。四元数的一般形式：<br>$$<br>\begin{equation}<br>q=s+xi+yj+zk \quad s,x,y,z \in R<br>\tag{11}<br>\end{equation}<br>$$<br>其中有如下性质：<br>$$<br>i^{2}=j^{2}=k^{2}=ijk=-1<br>$$<br>以及与笛卡尔坐标系下单位向量叉积规则很类似的等式：<br>$$<br>ij=k \quad jk=i \quad ki=j<br>$$</p>
<h4 id="有序数的四元数"><a href="#有序数的四元数" class="headerlink" title="有序数的四元数"></a>有序数的四元数</h4><p>我们可以用有序对的形式来表示四元数：<br>$$<br>\begin{equation}<br>[s,v] \quad s \in R, v \in R^{3}<br>\tag{12}<br>\end{equation}<br>$$<br>使用这种表示法，我们可以更容易地展示四元数和复数之间的相似性。其二元形式可以表示为：<br>$$<br>q=s+v<br>\tag{13}<br>$$</p>
<h4 id="四元数的共轭"><a href="#四元数的共轭" class="headerlink" title="四元数的共轭"></a>四元数的共轭</h4><p>四元数的共轭就是将虚向量取反：<br>$$<br>q^{-1} = s-v<br>\tag{14}<br>$$</p>
<h4 id="四元数的乘积"><a href="#四元数的乘积" class="headerlink" title="四元数的乘积"></a>四元数的乘积</h4><p>四元数的乘积可以表示为：<br>$$<br>q<em>{1}q</em>{2}=s<em>{1}s</em>{2}-v<em>{1} \cdot v</em>{2}+s<em>{1}v</em>{2}+s<em>{2}v</em>{1}+v<em>{1} \times v</em>{2}<br>\tag{15}<br>$$<br><em>对于四元数，还有很多的数学性质，有兴趣的话可以去查看相关的资料，这里不再累述。</em></p>
<h3 id="四元数的旋转"><a href="#四元数的旋转" class="headerlink" title="四元数的旋转"></a>四元数的旋转</h3><p><em>这里只参考3D游戏与计算机图形学中的数学方法一书并加上作者的看法来讲述四元数，这块的数学方法比较复杂，不做更深入的讨论</em></p>
<h4 id="同态函数的证明"><a href="#同态函数的证明" class="headerlink" title="同态函数的证明"></a>同态函数的证明</h4><p>三维空间的旋转可以看成函数在三维向量空间内的映射变换。这个函数表示的是一个旋转变换$\phi$，必须保持长度、角度和偏手性不变。如果下式成立，则函数$\phi$可以保持旋转向量的长度不变性。<br>$$<br>||\phi(P)||=||P||<br>\tag{16}<br>$$<br>对于三维空间中的点：$P_1$和$P<em>2$，连接坐标系原点与这两个点的线段之间的夹角如果满足以下条件，在旋转过程中可保持不变(<em>对两个向量做同一变换不应改变向量之间的夹角</em>)：<br>$$<br>\phi(P</em>{1}) \cdot \phi(P<em>{2}) = P</em>{1} \cdot P<em>{2}<br>\tag{17}<br>$$<br>我们对向量的点积使用$\phi$，那么也应该保证旋转长度不变性：<br>$$<br>\phi(P</em>{1}) \cdot \phi(P<em>{2}) = P</em>{1} \cdot P<em>{2} = \phi(P</em>{1} \cdot P<em>{2})<br>\tag{18}<br>$$<br>同理旋转过程中偏手性也不应该改变：<br>$$<br>\phi(P</em>{1}) \times \phi(P<em>{2}) = \phi(P</em>{2} \times P_{2})<br>\tag{19}<br>$$<br>我们将$P_1$和$P<em>2$看作是标量为0的四元数，结合上面的可得：<br>$$<br>P</em>{1}P<em>{2}=-P</em>{1} \cdot P<em>{2} + P</em>{1} \times P<em>{2}<br>$$<br>结合上面的公式，我们可以得倒：<br>$$<br>\begin{align}<br>&amp;\phi(P</em>{1}P<em>{2}) = -\phi(P</em>{1} \cdot P<em>{2}) + \phi(P</em>{1} \times P<em>{2}) \<br>&amp;\phi(P</em>{1}P<em>{2}) = -\phi(P</em>{1}) \cdot \phi(P<em>{2}) + \phi(P</em>{1}) \times \phi(P<em>{2}) \<br>\end{align}<br>$$<br>这里$\phi(P</em>{1})$和$\phi(P<em>{2})$表示的是经过旋转变换后的四元数，那么上面式子的右式就可以写成 $\phi(P</em>{1})\phi(P<em>{2})$。则有：<br>$$<br>\phi(P</em>{1}P<em>{2}) = \phi(P</em>{1})\phi(P_{2})<br>\tag{20}<br>$$<br>满足此式的函数称为同态函数，保证了角度不变性和偏手性不变性的条件。</p>
<h4 id="旋转公式的推导"><a href="#旋转公式的推导" class="headerlink" title="旋转公式的推导"></a>旋转公式的推导</h4><p><a href="https://math.stackexchange.com/questions/1410343/definition-of-homeomorphic" target="_blank" rel="noopener">同态函数</a>有一个很重要的<a href="http://www.math.uconn.edu/~kconrad/blurbs/grouptheory/homomorphisms.pdf" target="_blank" rel="noopener">性质</a>：</p>
<p>&emsp;&emsp;<strong>给定一个G集合中的元素g，有变换$\gamma<em>{g}=gxg^{-1}$将其变化到，$\gamma</em>{g}:G \to G$这时是同$\gamma_{g}$态的</strong>。<br>$$<br>\begin{equation}<br>\gamma<em>{g}(x)\gamma</em>{g}(y)=(gxg^{-1})(gyg^{-1})=gxg^{-1}gyg^{-1}=gxyg^{-1}=\gamma<em>{g}(xy)<br>\tag{21}<br>\end{equation}<br>$$<br>同态函数要保证$\gamma</em>{g}$经过$\gamma<em>{g^{-1}}$样一个逆变换后可以变换回原本的元素g，那么我们有：<br>$$<br>\begin{equation}<br>\gamma</em>{g^{-1}}(\gamma<em>{g}(x))=\gamma</em>{g^{-1}}(gxg^{-1})=g^{-1}(gxg^{-1})g=g^{-1}gxg^{-1}g=x<br>\end{equation}<br>$$<br>对于任意的$x \in G$，与$\gamma<em>{g^{-1}}$和可逆$\gamma</em>{g}$且互为逆变换。</p>
<h5 id="四元数的旋转-1"><a href="#四元数的旋转-1" class="headerlink" title="四元数的旋转"></a>四元数的旋转</h5><p>现在我们设q为非0的四元数，表示旋转变换函数的集合，有：<br>$$<br>\phi_{q}(P)=qPq^{-1}<br>\tag{22}<br>$$<br>令$q=s+v$为一个单位四元数，则$q^{-1}=s-v$，对于三维空间中的点P(相当于一个实数项为0的四元数，方便使用四元数的乘积)，有：<br>$$<br>\begin{align}<br>qPq^{-1}&amp;=(s+v)P(s-v) \<br>&amp;=(-v \cdot P + sP + v \times P)(s-v) \<br>&amp;=s^{2}P + 2sv \times P + (v \cdot P)v - v \times P \times v<br>\end{align}<br>$$<br>因为$v \times P \times V=v^2P-(v \cdot P)P$，所以可化简为：<br>$$<br>qPq^{-1}=(s^2-v^2)P+2sv \times P + 2(v \cdot P)v<br>$$<br>令$v=s\overrightarrow{A}$，其中$\overrightarrow{A}$为单位向量：<br>$$<br>qPq^{-1}=(s^{2}-v^{2})P + 2stA \times P + 2t^{2}(A \cdot P)A<br>$$<br>与之前绕任意轴旋转的旋转公式相比，可得：<br>$$<br>\begin{align}<br>&amp;s^2 - t^2 = cos\theta \<br>&amp;2st = sin\theta \<br>&amp;2t^2 = 1 - cos\theta<br>\end{align}<br>$$<br>可得：<br>$$<br>t=sin\frac{\theta}{2}<br>$$<br>可得绕轴$\overrightarrow{A}$旋转$\theta$角对应的单位四元数$\overrightarrow{q}$的表达式为：<br>$$<br>q=cos\frac{\theta}{2} + Asin\frac{\theta}{2}<br>\tag{23}<br>$$<br>我们知道，计算两个四元数的乘积只需要16次乘-加运算，而计算两个$3 \times 3$矩阵的乘积需要27次这样的运算。因此对一个向量做多次旋转操作时，使用四元数进行变换可以提高计算效率。</p>
<p>在实际编程中，我们经常要将四元数变成与其等效的$3 \times 3$矩阵，其中具体的数学推到比较复杂，可以参考<a href="https://item.jd.com/11974448.html" target="_blank" rel="noopener">3D游戏与计算机图形学中的数学方法</a>，我们这里不再累述。在代码中，我们可以使用<em>GLM</em>轻松地将四元数旋转转化为对应的旋转矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mat4 model = glm::mat4_cast(q);</span><br></pre></td></tr></table></figure>
<p><em>四元数还有一篇比较经典的<a href="https://www.3dgep.com/understanding-quaternions/" target="_blank" rel="noopener">文章</a>可供参考。另外，有一个重要的球型线性插值没有介绍，未来在human-motion的实践中再进行补充。</em></p>
<h3 id="Quaternion-camera">Quaternion Camera</h3>

<h2 id="Appendix-reference">Appendix &amp; Reference</h2>
      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: 'Donate', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: '',
  alipayImage: ''
});
</script>
      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/">Computer Graphics</a></li></ul>

    </footer>
  </div>
  
    
  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Coordinate-Transformation-From-Euler-to-Quaternion"><span class="nav-number">1.</span> <span class="nav-text">Coordinate Transformation: From Euler to Quaternion</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">1.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linear-Transformation"><span class="nav-number">1.2.</span> <span class="nav-text">Linear Transformation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scale-Transformation"><span class="nav-number">1.3.</span> <span class="nav-text">Scale Transformation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Euler-Rotation"><span class="nav-number">1.4.</span> <span class="nav-text">Euler Rotation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Rotation-Matrix"><span class="nav-number">1.4.1.</span> <span class="nav-text">Rotation Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Rotate-with-arbitrary-axis"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Rotate with arbitrary axis</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Euler-Camera"><span class="nav-number">1.4.2.</span> <span class="nav-text">Euler Camera</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#摄像机位置"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">摄像机位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#摄像机方向"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">摄像机方向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#右轴"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">右轴</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#上轴"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">上轴</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Look-at-Matrix"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">Look-at Matrix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自由移动"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">自由移动</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#移动速度"><span class="nav-number">1.4.2.6.1.</span> <span class="nav-text">移动速度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#视角移动"><span class="nav-number">1.4.2.7.</span> <span class="nav-text">视角移动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Euler-Drawback"><span class="nav-number">1.4.3.</span> <span class="nav-text">Euler Drawback</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Quaternion-Rotation"><span class="nav-number">1.5.</span> <span class="nav-text">Quaternion Rotation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Complex"><span class="nav-number">1.5.1.</span> <span class="nav-text">Complex</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二维空间上的旋转"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">二维空间上的旋转</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quaternion-Theory"><span class="nav-number">1.5.2.</span> <span class="nav-text">Quaternion Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有序数的四元数"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">有序数的四元数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四元数的共轭"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">四元数的共轭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四元数的乘积"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">四元数的乘积</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四元数的旋转"><span class="nav-number">1.5.3.</span> <span class="nav-text">四元数的旋转</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同态函数的证明"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">同态函数的证明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#旋转公式的推导"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">旋转公式的推导</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#四元数的旋转-1"><span class="nav-number">1.5.3.2.1.</span> <span class="nav-text">四元数的旋转</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quaternion-camera"><span class="nav-number">1.5.4.</span> <span class="nav-text">Quaternion Camera</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Appendix-reference"><span class="nav-number">1.6.</span> <span class="nav-text">Appendix &amp; Reference</span></a></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2018 - 2018 technician tech All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				UV : <span id="busuanzi_value_site_uv"></span> |  
				PV : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            technician tech
          </div>
          <div class="panel-body">
            Copyright © 2018 technician tech All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>