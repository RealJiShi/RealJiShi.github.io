<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OpenGL Fixed Pipeline]]></title>
    <url>%2F2018%2F03%2F28%2Fopengl-fixed-pipeline%2F</url>
    <content type="text"><![CDATA[OpenGL中的固定管线函数 OpenGL的pipeline中，有像 vertex shader、geometry shader 和 fragment shader 等的可编程管线，也有像depth test(z-buffering)、stencil test、alpha test 等由Host控制状态，GPU自动处理的渲染过程。我们这里主要介绍 fragment shader 之后的固定管线函数及其原理。 计算机图形学的目的就是计算出一副图像的颜色值 OpenGL Buffer Overview Pixel Ownership Test Scissor Test Stencil Test Alpha Test Depth Test Alpha Blend Dithering Reference OpenGL Buffer Overview 几乎所有图形程序都共有一个目标，就是在屏幕上绘制图像（或者绘制到离屏的一处帧缓冲中）。 帧缓冲（通常是屏幕）是由矩形的像素数组组成的，每个像素都可以在图像对应的点上显示一小方块的颜色值。经过光栅化阶段和执行片元着色器之后，得到的数据还不是真正的像素–只是候选的片元。每个片元都包含于像素位置对应的坐标数据，以及颜色和深度的存储值。通常OpenGL包含如下几种缓冲： 一个或多个color buffer（多渲染目标Multiple Render Targets，G缓冲） 深度缓冲 模板缓冲 OpenGL管线中，在顶点着色之后要进行的操作是光栅化(rasterization)。它主要会判断屏幕空间的哪个部分被几何体覆盖，线性化插值（倒数）顶点属性，比如 Gouraud 着色等等（即 Fragment Shader 中输入的属性不是 Vertex Shader 中传出的属性，而是属性的线性插值）。光栅化相当于一个片元生命的开始，而Fragment Shader的本质相当于计算这个片元最终的颜色。后文将会介绍管线中对各个片元的测试和操作（又叫Per-Sample Processing），它们将真正决定一个片元最终能否成为帧缓冲中的一个像素。 Pixel Ownership Test 默认缓冲对于OpenGL而言属于外部资源，所以对于默认缓冲上的某些像素，它们可能不属于OpenGL，所以 OpenGL 不能写入这些像素。Pixel OwnerShip Test 就是为了检测这样的像素并且在pipeline 中将其丢弃。通常来说，如果渲染用的图形窗口被另一窗口所遮挡，亦被遮挡的像素不再属于OpenGL，这部分像素会被丢弃因为它们通不过像素所有权测试。 Pixel Ownership Test仅仅影响默认帧缓冲。对于Framebuffer对象没有任何影响，其中所有的像素都会通过测试 Scissor Test Scissor Test 是片元可见性判断的第一个附加测试。我们将程序窗口的一个矩形区域称作一个剪裁盒，并且将所有的绘制操作都限制在这个区域内。我们可以用glScissor命令来设置这个剪切盒，并且使用glEnable来开启测试。具体代码如下： glEnable(GL_SCISSOR_TEST); glScissor( x, y, width, height ); // rendering loop... 如果开启测试，那么所有的渲染、清除等都被限制在剪切和区域内。通常，我们可以使用 Scissor Test 操作来做 Picture-in-picture 操作，大概的代码流程如下： // rendering loop glViewport( 0, 0, SCR_WIDTH, SCR_HEIGHT ); render(); // render normal // rendering glViewport( x, y, width, height ); glEnable(GL_SCISSOR_TEST); glScissor( x, y, width, height ); render(); // render Picture-in-picture glDisable(GL_SCISSOR_TEST); 这里要注意的是，屏幕坐标从左下角开始(即0,0) Stencil Test 模板测试本质上就是设定一个Mask，将 fragment 和mask做比较，如果符合条件则保留 fragment，反之则丢弃。一个模板缓冲中，（通常）每个模板值(Stencil Value)是8位的。所以每个像素/片段一共能有256(0xFF)种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。这里我们用LearnOpenGL中的例子来说明： Stencil Buffer的使用 首先我们需要清空模板缓冲（此时的值为0）： glClear(GL_STENCIL_BUFFER_BIT); 接着，模板缓冲允许我们在渲染片段时将模板设定为一个特定的值。通过在渲染时修改模板缓冲的内容，我们写入模板缓冲。在同一帧的渲染中，我们可以读取这些值来决定丢弃还是保留某个片段。大体的过程如下： 启动模板缓冲: glEnable(GL_STENCIL_TEST) 清空模板缓冲: glClear(GL_STENCIL_BUFFER_BIT) 设置模板缓冲更新函数: // func -- GL_ALWAYS, GL_NEVER... // ref -- Reference Value, stencil buffer will compare with this value // mask -- AND operation before comparing with ref glStencilFunc(GLenum func, GLint ref, GLuint mask) 渲染物体(可以理解为Mask)，更新模板缓冲的内容 禁止模板缓冲的写入： glStencilMask(0x00) 渲染其他物体，这次根据模板缓冲的内容丢弃特定的片段 模板测试的应用-提取物体轮廓 同样我们从LearnOpenGL中选取了物体轮廓的例子来讲述如何使用模板测试。我们可以给某个物体在他周围创建一个很小的有色边框，步骤如下： 在绘制（需要添加轮廓的）物体之前，将模板函数设置为GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为1。 设置 glStencilMask(0x00)，绘制不希望写入模板缓存的物体，比如地板，天空盒 渲染物体 禁用模板写入以及深度测试 将物体放大一点 使用一个不同的fragment shader，其作用是输出一个单独的边框颜色 渲染物体，但是只有fragment的模板值不等于1时才绘制 恢复上下文中的模板和深度状态 Alpha Test Alpha Test 就是测试每一个像素的Alpha值是否满足某一个特定的条件，如果满足，则该像素会被绘制，不满足则丢弃。早期OpenGL中经常用： glEnable( GL_ALPHA_TEST ); glAlphaFunc( GL_GREATER, 0.1f ); // rendering glDisable( GL_ALPHA_TEST ); 在Modern OpenGL 中，可以在fragment shader中直接根据alpha的值丢弃fragment： // glsl #version 330 core in vec2 TexCoords; out vec4 FragColor; uniform texture2D tex; uniform float alpha; void main() { vec4 color = texture( tex, TexCoords ); if ( color.a &lt; alpha ) { discard; } FragColor = color; } 借用LearnOpenGL Blend中的一个例子，我们可以看到如下结果： Depth Test 对于屏幕上的每个pixel而言，深度缓存都会记录场景中物体与视点在这个像素上的距离信息。如果输入的深度值可以通过指定的深度测试环节，那么它就可以替换当前的深度缓存中已有的深度值，新像素值会取代原先的；如果没有通过深度测试，则丢弃当前fragment。下图就是使用深度测试后的效果： 深度缓冲的创建 深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式存储他的深度值，大部分系统的深度缓冲精度都是24位，在fragment shader中，其值的范围在0.0-1.0之间。 深度缓冲的使用 深度测试默认是禁用的，通过GL_DEPTH_TEST可以启用它： glEnable(GL_DEPTH_TEST); 如果启用了深度测试，那么在每次渲染的时候都需要清空深度缓冲（每次渲染迭代，渲染到framebuffer），我们可以使用GL_DEPTH_BUFFER_BIT来清空深度缓冲： glClear(GL_DEPTH_BUFFER_BIT); 深度测试函数 OpenGL允许我们修改深度测试中使用的比较运算符，这允许我们来控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。我们可以调用glDepthFunc来设置比较运算符： glDepthFunc(GL_LESS); OpenGL默认使用GL_LESS作为比较运算符，还有诸如GL_AWALYS,GL_NEVER等方式。下面是我们将运算符设置为GL_ALWAYS时的输出效果图。 深度值的访问 在GLSL中，我们可以通过gl_FragCoord从片段着色器中直接访问。gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。gl_FragCoord中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。 深度值的数学原理 如果对投影变换有所了解的话，就会知道顶点属性是坐标值倒数的线性插值。那么通过一系列的透视投影变换以后，我们可以得倒Normal Device Coordinates下深度值的表达式： $$\begin{equation}\tag{1}z = -\frac{2near \cdot far}{far-near}\frac{1}{P_{z}} + \frac{far+near}{far-near}\end{equation}$$ 其中\(P_{z}\)表示当前点P的z值。 我们将\(z’=2Depth_{frag}+1\)带入上式中，得： $$\begin{equation}\tag{2}F_{depth} = \frac{1/Depth_{frag} - 1/near}{1/far - 1/near}\end{equation}$$ 同样的，在fragment shader中，我们已知gl_FragCoord,那么就可以通过下式求出对应的NDC坐标了： $$\begin{equation}\tag{3}z = \frac{2near \cdot far}{far+near-gl\_FragCoord.z \cdot (far-near)}\end{equation}$$ 深度缓冲的可视化 我们可以根据fragment的深度值返回一个颜色向量来完成深度缓冲的可视化： void main() { FragColor = vec4(vec3(gl_FragCoord.z), 1.0); } 在fragment shader中我们可以描述其为： #version 330 core out vec4 FragColor; uniform float near; uniform float far; float LinearizeDepth( float depth ) { return (2.0 * near * far) / (far + near - z * (far - near)); } void main() { float depth = LinearizeDepth(gl_FragCoord.z); FragColor = vec4(vec3(depth), 1.0); } Z-fighting 一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。防止z-fighting技巧有很多： 不要把物体放的太近 将近平面设的远一些 使用更高精度的深度缓冲(GL_DEPTH COMPONENT32F) Polygon offset Polygon Offset Polygon offset用于解决线和填充多边形的光栅化过程不一致导致的 stitching 问题，也可以解决 Z-fighting 问题。启动多边形偏移的方法有三种，分别对应三种不同的光栅化方式：GL_FILL，GL_LINE，G:_POINT。通常我们的做法是： glEnable()传入对应的参数来开启多边形偏移，即GL_POLYGON_OFFSET_FILL，GL_POLYGON_OFFSET_LINE，GL_POLYGON_OFFSET_POINT 接着在每个渲染之前，使用glPolygonOffset给当前对象设置一个深度偏移 // offset = m*factor + r * units // m - max depth slope // r - min acceptable depth difference // factor can be set (1.0, 1.0) ... void glPolygonOffsetr(GLfloat factor, GLfloat units); 渲染对象 设置下一个要渲染对象的深度偏移，重复上述操作 代码如下： // opengl setting glEnable( GL_DEPTH_TEST ); glEnable( GL_POLYGON_OFFSET_FILL ); // rendering loop while ( !glfwWindowShouldClose(window) ) { // pre-process ... // glm::mat4 view = camera.getViewMatrix(); glm::mat4 projection = glm::perspective( glm::radians(camera.Zoom), (float)SCR_WIDTH / SCR_HEIGHT, 0.1f, 100.0f ); // rendering shader.use(); shader.setMat4( &quot;view&quot;, glm::value_ptr(view) ); shader.setMat4( &quot;projection&quot;, glm::value_ptr(projection) ); // 1st glm::mat4 model(1); model = glm::translate( model, glm::vec3( 1.0f, 0.0f, 0.0f ) ); shader.setMat4( &quot;model&quot;, glm::value_ptr(model) ); shader.setVec3( &quot;color&quot;, 1.0f, 0.0f, 0.0f ); glPolygonOffset( -1.0, -1.0 ); renderSquard(); // 2nd model = glm::mat4(1); model = glm::translate( model, glm::vec3( -1.0f, 0.0f, 0.0f ) ); shader.setMat4( &quot;model&quot;, glm::value_ptr(model) ); shader.setVec3( &quot;color&quot;, 0.0f, 1.0f, 0.0f ); glPolygonOffset( -2.0, -2.0 ); renderSquard(); // 3rd model = glm::mat4(1); model = glm::translate( model, glm::vec3( 0.0f, 1.0f, 0.0f ) ); shader.setMat4( &quot;model&quot;, glm::value_ptr(model) ); shader.setVec3( &quot;color&quot;, 0.0f, 0.0f, 1.0f ); glPolygonOffset( -3.0, -3.0 ); renderSquard(); // post-process... } Disable and Enable polygon offset Alpha Blend 如果一个fragment通过了所有的测试，那么它就可以和颜色缓存中当前的内容进行合并了。最简单的自然是覆盖之前的颜色。除此之外，我们还可以用混合，将当前fragment和color buffer中的像素进行alpha的融合，产生出一种透明的效果。OpenGL中混合是通过如下公式实现的： $$\begin{equation}\tag{4}Color_{result} = Color_{source} \cdot F_{source} + Color_{destination} \cdot F_{destination}\end{equation}$$ \( F_{source}\)：源因子值，即alpha值对color buffer当前像素的影响 \( F_{destination}\)：源因子值，即alpha值对fragment的影响 为了实现上述方程，OpenGL为我们提供了glBlendFunc： // sfactor, dfactor: GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA... glBlendFunc(GLenum sfactor, GLenum dfactor); 通常，我们只用在初始化的时候开启混合： glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 开启混合之后，如果我们直接绘制场景，那么会得到如下效果： 可以发现，透明的部分遮挡了背后的窗户。原因是，深度测试和混合一起使用的话会产生一些麻烦。当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们，LearnOpenGL Blend。 为了能够正确的使用混合，保证先绘制最远的物体，最后绘制最近的物体，我们需要对深度进行排序。排序透明物体的一种方法是，从观察者视角获取物体的距离。这可以通过计算摄像机位置向量和物体的位置向量之间的距离所获得LearnOpenGL Blend。最终我们可以得下图： Dithering 对于颜色位数目比较小的系统来说，我们可以通过对图像中的颜色进行抖动(dithering)来提升颜色的分辨率（代价是损失一部分空间分辨率–像素有偏移）。对于颜色位数较小的系统，我们可以将临近像素的红色、绿色和蓝色进行抖动，以模拟更大范围的色彩变化。dithering 本身是和硬件相关的。OpenGL 能做的只是开启或关闭这个特性。事实上，在某些颜色分辨率非常高的机器上，如retina，那么开启抖动可能不会产生任何的效果，默认情况下dithering 是开启的。 glEnable( GL_DITHER ); glDisable( GL_DITHER ); Reference OpenGL Pixel Ownership Test LearnOpenGL 深度测试 OpenGL中真正的深度值-z-buffer探究 LearnOpenGL 模板测试]]></content>
      <tags>
        <tag>Computer Graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL Pipeline]]></title>
    <url>%2F2018%2F03%2F13%2FOpenGLPipeline%2F</url>
    <content type="text"><![CDATA[OpenGL Pipeline OpenGL 实现了我们通常说的渲染管线(rendering pipeline)，它是一系列数据处理过程，并且将应用程序的数据转换到最终渲染的图像。OpenGL首先接收用户提供的几何数据（顶点和和几何图元），并且将它输入到一系列着色器阶段中处理，包括：定点着色、细分着色、几何着色，然后将几何数据送入光栅化单元（rasterizer）。光栅化单元负责对所有剪切区域（clipping region）内的图元生成片元数据，然后对每个生成的片元着色器。 OpenGL Host向OpenGL传输数据 在Modern OpenGL中，host（CPU端，也称服务端）会设置一个有序的顶点列表，并把这些数据送到流水线，这些顶点定义了原图形的属性：形状、点、法线、纹理坐标等等，同时也告诉了OpenGL如何去解读这些数据(Vertex Array Object)。 OpenGL需要将所有的数据都保存到缓存对象(Vertex Buffer object等等)， 它相当于由OpenGL服务端维护的一块内存区域（主机上）。创建这样的数据缓存，不过最常用的方法就是使用glBufferData()命令。 将数据传输到OpenGL缓存初始化之后，我们就可以在host上通过调用OpenGL的一个绘制指令来请求渲染几何图元，例如glDrawArrays()。OpenGL的绘制通常是将顶点数据发送到OpenGL服务端，通常来说就是显卡。我们可以将一个顶点视为一个需要统一处理的数据包，其可以包含任何数据（位置、纹理、颜色、法向量等等）。 Vertex Rendering顶点着色 顶点着色器对每个独立的顶点进行基础处理，顶点Shader接受输入属性，并且基于用户定义的程序，将每个输入的顶点转换为一一对应输出顶点。 顶点Shader可以使用用户自定义的输出，但是也有一个特殊的输出gl_Position，代表顶点的最终位置，一般填充为裁剪空间的顶点位置。 一个限制是，在顶点处理过程中，因为各个顶点shader之间的不可共享状态，任何一个输入属性必须被映射到唯一一个顶点输出中。如果你填充了完全相同的属性到相同的顶点Shader中的相同原图形中，那么你将会获得相同的输出顶点数据。 一个复杂的程序可能会有多个顶点着色器，但是同一时刻只有一个起作用 细分着色 细分着色器会使用patch来描述一个物体的形状，并且使用相对简单的Patch几何体连接来完成细分的工作，其结果是几何图元数量增加，使得模型外观会变的更为平顺 细分着色器分为控制和计算两个步骤 几何着色 几何Shader是用户自定义的程序，处理每个输入原图形，并产生0-n个输出原图形。一个很典型的应用就是计算每个顶点的法向量。 Vertex Post-Processing 经过基于Shader的（可编程的）顶点处理之后，顶点会执行一系列的固定管线函数处理，由Host(context)来控制。 图元装配 图元装配阶段将之前顶点和相关的几何图元之间组织起来，准备下一步的剪裁和光栅化工作。 剪切 原图形随后被裁切，裁切意味着，在边界上的原图形，将会被分离成几部分原图形，这样所有的全图型，都将保证在视空间之内。 同时，最后的顶点处理Shader也可以执行用户自定义操作。顶点位置在透视分割和视图转换时，被转换到裁切空间。 面剔除 三角形元数据可以被剔除，这基于三角形面在窗口空间的朝向。他允许你不渲染背对观察者的三角形。这些三角形会被离观察者近的面挡住，所以你永远没有必要去渲染他们。 光栅化 剪切之后马上要执行的工作，就是将更新后的图元传递到光栅化单元中，生成对应的片元。我们可以将一个片元视为一个候选像素，也就是可以放置在帧缓存中的像素。 以屏幕而发出均匀扫描线，而此时由于图元是3D的，所以会进行非均匀采样，这样我们就能将图元映射到屏幕上。 这个过程可以选择性的进行多重采样。（anti-aliasing） 片元着色 光栅化过程中产生的片段数据，将由片段Shader进行处理。片段Shader的输出是为每个颜色Buffer写入的颜色列表，一个深度值和一个模板值。片段程序无法为片段设置模板值，但是可以控制颜色和深度值。 片段Shader也是可选的。如果你不使用片段Shader，深度（和模板）值，将是他们的通常值。但是所有片段的颜色值是未定义的。不使用片段Shader进行渲染，在我们只想将一个原图形的深度信息写入到深度缓冲的时候，会显得非常有用，比如在做 遮挡查询（Occlusion Query ）测试的时候。 逐片元操作剔除测试剔除测试是由Host context实现，如果测试被激活且片段没有通过测试，对应的像素或者采样将不会被更新（discard）： 像素所有权测试 剪刀测试(Scissor Test)：当片段的像素位于指定的屏幕的矩形区域之外的时候，测试将会失败 模板测试(Stencil Test)：如果被激活，如果测试提供的模板值，与用户指定的模板缓冲中的值无法匹配，那么测试将会失败 深度测试(Depth Test，z-buffering)：如果被激活，当片段的深度值，与用户指定的深度缓冲中的深度值，不匹配，那么测试将会失败 Alpha Test 混合 对于每一个片段颜色值，在已经在FrameBuffer中的颜色值，和当前颜色值之间，有一个特殊的混合操作 推荐文章（由hexo文章推荐插件驱动）Coordinate Transformation]]></content>
      <tags>
        <tag>Computer Graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coordinate Transformation]]></title>
    <url>%2F2018%2F02%2F07%2FCameraMatrix%2F</url>
    <content type="text"><![CDATA[Coordinate Transformation: From Euler to Quaternion Introduction Linear Transformation Scale Transformation Euler Rotation Rotation Matrix Euler Camera Euler Drawback Quaternion Rotation Complex Quaternion Theory Quaternion Camera Appendix &amp; Reference Introduction坐标变换是将三维空间的一组向量从一个坐标空间变换到另一个坐标空间，其中可分为线性、比例、平移和旋转变换。我们这里使用OpenGL实现文中算法，用GLM库来组织数据，并且使用GLFW作为OpenGL的窗口，日后我们会升级为Qt。 Linear Transformation线性变换很简单，可以表示为：$$\begin{equation}\begin{bmatrix} x’\\ y’\\ z’\ \end{bmatrix} =\begin{bmatrix} U_{1} &amp; V_{1} &amp; W_{1} \\ U_{2} &amp; V_{2} &amp; W_{2} \\ U_{3} &amp; V_{3} &amp; W_{3} \ \end{bmatrix}\begin{bmatrix} x\\ y\\ z\ \end{bmatrix} +\begin{bmatrix} T_{1}\\ T_{2}\\ T_{3}\ \end{bmatrix}\tag{1}\end{equation}$$有一个比较重要的概念是正交矩阵，其是由n个正交的基向量构成。其中：$$M^{-1} = M^{T} \tag{2}$$(2)式可以简化正交矩阵的求逆， 将其转化为矩阵的转秩。 Scale Transformation比例变换也很简单：$$\begin{equation}\begin{bmatrix} x’ \\ y’ \\ z’\ \end{bmatrix} =\begin{bmatrix} a &amp; &amp; \\ &amp; b &amp; \\ &amp; &amp; c \ \end{bmatrix}\begin{bmatrix} x \\ y \\ z\ \end{bmatrix}\tag{3}\end{equation}$$如果a,b,c相等为等比例缩放。 Euler RotationRotation Matrix通过一个$3 \times 3$矩阵，我们可以将一个坐标绕x，y，z旋转$\theta$角。 首先讨论二维空间的旋转公式，对于x-y平面中的一个二维向量，将x和y坐标交换，并且将交换后的x坐标取反，就实现了向量$\overrightarrow{P}$的$90^{\circ}$逆时针旋转，即向量$\overrightarrow{Q}$。$\overrightarrow{P}$与$\overrightarrow{Q}$构成一对二维空间正交基。现有一向量$\overrightarrow{P’}$，是$\overrightarrow{P}$旋转$\theta$所得，那么有：$$\begin{equation}P’ = Pcos\theta + Qsin\theta\tag{4}\end{equation}$$展开：$$\begin{align}P_{x}’ = xcos\theta - ysin\theta \\P_{y}’ = xcos\theta + ysin\theta\end{align}$$展开成矩阵的形式：$$\begin{equation}\begin{bmatrix} P_{x}’ \\ P_{y}’\end{bmatrix} =\begin{bmatrix} cos\theta &amp; -sin\theta \\ sin\theta &amp; cos\theta \end{bmatrix}\end{equation}$$下面是分别绕x,y,z轴的旋转矩阵：$$\begin{equation}R_{x}(\theta) =\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; cos\theta &amp; -sin\theta \\ 0 &amp; sin\theta &amp; cos\theta \end{bmatrix}\tag{5}\end{equation}$$ $$\begin{equation}R_{y}(\theta) =\begin{bmatrix} cos\theta &amp; 0 &amp; sin\theta \\ 0 &amp; 1 &amp; 0 \\ -sin\theta &amp; 0 &amp; cos\theta \end{bmatrix}\tag{6}\end{equation}$$ $$\begin{equation}R_{z}(\theta) =\begin{bmatrix} cos\theta &amp; -sin\theta &amp; 0 \\ sin\theta &amp; cos\theta &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\tag{7}\end{equation}$$ Rotate with arbitrary axis关于任意轴的旋转可以省略，但是这一小节在四元数的证明中很有用。 将向量$\overrightarrow{P}$绕任意轴旋转$\theta$角，单位向量$\overrightarrow{A}$表示一个旋转轴，那么向量$\overrightarrow{P}$可分解为与向量$\overrightarrow{A}$平行和垂直的分量。由于与向量$\overrightarrow{A}$平行的分量在旋转过程不变，那么问题就转化为向量$\overrightarrow{P}$与向量$\overrightarrow{A}$垂直分量的旋转问题。首先，将向量$\overrightarrow{P}$在向量$\overrightarrow{A}$的投影与垂直分量表示为：$$\begin{align}proj_{A}P&amp; = (A \cdot P)A \\perp_{A}P&amp;= P - (A \cdot P)A\end{align}$$我们知道向量$\overrightarrow{P}$的垂直分量绕$\overrightarrow{A}$的旋转是在向量$\overrightarrow{A}$垂直平面内，结合我们之前二维空间旋转矩阵的证明公式，需要找到一个逆时针旋转$90^\circ$的向量用以构成一对正交基。这个向量很容易找到，即向量$\overrightarrow{A}$与向量$\overrightarrow{P}$的叉乘。则将垂直分量旋转$\theta$：$$[P - (A \cdot P)A]cos\theta + (A \times P)sin\theta$$加上水平投影分量得$\overrightarrow{P}$绕$\overrightarrow{A}$旋转$\theta$的解：$$\begin{equation}P’ = Pcos\theta + (A \times P)sin\theta + (A \cdot P)A(1 - cos\theta)\tag{8}\end{equation}$$ Euler Camera其实在OpenGL中没有Camera的概念，但是通常的做法是反方向移动场景中所有物体来模拟出摄像机的视角，产生出一种摄像机在移动而非场景移动。 其实对于摄像机（即观察空间），我们的目标是找到一个坐标系可以将场景中所有的物体变换到此空间中。那么我们的目标就是找到一组正交基，构成这样一个摄像机空间。具体来说要定义一个摄像机，我们需要它在世界空间中的位置、观察方向、一个指向它右侧的向量和一个指向它上方的向量，如想图所示： 摄像机位置摄像机的位置非常简单，用代码我们可以表示为： 1glm::vec3 cameraPos = glm::vec3( 0.0f, 0.0f, 3.0f ); 摄像机方向摄像机的方向是相机位置减去目标位置所得的向量，指向相机z轴正方向。 1glm::vec3 cameraDirection = glm::normalize( cameraPos - cameraTarget ); 右轴右向量表示摄像机x轴的正方向。可以观察到（下文会有描述），因为在二维屏幕上，我们只能对相机进行俯仰(pitch)与偏航(yaw)，所以其上轴只能在y平面上。所以这里我们先定义一个上向量$(0,1,0)$，接着将上向量与摄像机方向做叉乘，就得到了右轴： 12glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection)); 上轴上轴现在就很好计算了： 1glm::vec3 cameraUp = glm::normalize(glm::cross(cameraDirection, cameraRight)); 实际上，求出这几个方向的方法叫做Gram-Schmidt Process，具体可以参考3D游戏与计算机图形学中的数学方法。 Look-at Matrix现在相机坐标系是相对于世界坐标系的。那么我们对上面的向量做逆变换，就可以将场景变换到相机坐标系中了。这里我们就得到了一个LookAt矩阵：$$\begin{equation}LookAt =\begin{bmatrix} R_{x} &amp; R_{y} &amp; R_{z} &amp; 0\\ U_{x} &amp; U_{y} &amp; U_{z} &amp; 0\\ D_{x} &amp; D_{y} &amp; D_{z} &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\ \end{bmatrix} *\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; -P_{x} \\ 0 &amp; 1 &amp; 0 &amp; -P_{y} \\ 0 &amp; 0 &amp; 1 &amp; -P_{z} \\ 0 &amp; 0 &amp; 0 &amp; 1 \ \end{bmatrix}\end{equation}$$这里，对于相机坐标位置向量所构成的矩阵求逆，因为其是正交矩阵，所以相当于对该矩阵求转秩。同时将世界平移到与我们自身移动相反方向就可以将世界坐标变换到观察空间中。 GLM已经提供了相关的实现，我们只需要定义一个相机位置，目标位置和世界空间中的上向量，GLM就会创建一个LookAt矩阵： 123456789#include &lt;glm/gtc/matrix_transform.hpp&gt; // glm::dmat4 glm::lookAt(// glm::dvec3 const &amp; eye,// glm::dvec3 const &amp; center,// glm::dvec3 const &amp; up);glm::mat4 view = glm::lookAt( glm::vec3( 0.0f, 0.0f, 3.0f ), glm::vec3( 0.0f, 0.0f, 0.0f ), glm::vec3( 0.0f, 1.0f, 0.0f ) ); 自由移动如果想让相机进行平移运动，那么要先定义一些摄像机变量： 123glm::vec3 cameraPos = glm::vec3( 0.0f, 0.0f, 3.0f );glm::vec3 cameraFront = glm::vec3( 0.0f, 0.0f, -1.0f ); // unit vectorglm::vec3 cameraUp = glm::vec3( 0.0f, 1.0f, 0.0f ); // unit vector 那么现在LookAt函数变成了： 1view = glm::lookAt( cameraPos, cameraPos + cameraFront, cameraUp ); 那么我们可以为GLFW的键盘输入定义一个processInput函数： 123456789101112void processInput(GLFWwindow *window) &#123; float cameraSpeed = 0.05f; if ( glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS ) &#123; cameraPos += cameraSpeed * cameraFront; &#125; else if ( glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS ) &#123; cameraPos -= cameraSpeed * cameraFront; &#125; else if ( glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS ) &#123; cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; &#125; else if ( glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS ) &#123; cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; &#125;&#125; 这样我们就实现了一个简单相机的平移。 移动速度目前我们的移动速度是个常量。理论上没有什么问题，但是实际情况下根据处理器的能力不同，有些人可能会比其他人每秒绘制更多帧，也就是以更高的频率调用processInput函数。结果就是，根据配置的不同，有些人可能移动很快，而有些人会移动很慢。当发布程序的时候，必须确保它在所有硬件上移动速度都一样。图形程序和游戏通常会追踪一个时间差$\delta$变量，它存储了渲染上一帧所用的时间。我们把所有速度都去乘$\delta(t)$值，结果就是，如果$\delta(t)$很大，就意味着上一帧的渲染花了更多时间，所以这一帧的速度需要变得更高去平衡渲染所花去的时间。使用这种方法是，无论计算机快慢，摄像机的速度都会平衡，这样每个用户的体验就是一样的了。 我们可以追踪两个全局变量来计算出$\delta(t)$值： 12float deltaTime = 0.0f;float lastFrame = 0.0f; 在每一帧中我们计算出新的deltaTime以备后用： 123float currentFrame = glfwGetTime();deltaTime = currentFrame - lastFrame;lastFrame = currentFrame; 这样就可以将速度考虑就去了： 1234void processInput(GLFWwindow *window) &#123; float cameraSpeed = 2.5f * deltaTime; ...&#125; 视角移动在视角移动中，通常使用欧拉角(Euler Angle)表示3D空间中任何旋转的三个值，分别是俯仰角(Pitch)、偏航角(Yaw)、滚转角(Roll)，如下图所示： 因为我们是在二维屏幕空间中操作摄像机，我们这里只关心俯仰角和偏航角，这里我们先从俯仰角开始： direction代表摄像机的前轴(Front) 从图中我们可以得倒： 1234direction.y = sin(glm::radians(pitch));// x and z should be changed toodirection.x = cos(glm::radians(pitch));direction.z = cos(glm::radians(pitch)); direction.x的变化是因为俯仰是针对于原点的俯仰，而非绕x轴俯仰。 对于偏航角： 123direction.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));direction.y = sin(glm::radians(pitch));direction.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw)); 到此为止，我们就可以创建一个摄像机类了，你可以在附件中找到我们想要的EulerCamera。 Euler Drawback使用欧拉角很容易引起的问题是万向锁. 这里有个视频详细的讲解了产生万向锁的原理。 简单来说，万向锁的产生是因为旋转时存在了父子旋转关系，比如a轴是b、c的父轴，那么a轴的旋转会带动b、c轴进行旋转，当出现了90度的旋转时，那么就会导致两个轴重合，这时就出现了万向锁。 对于我们上文中讲到的相机系统，他们的父子结构： 12x-&gt; y,z y-&gt; z 如果我们绕着上轴旋转$90^\circ$，那么z轴就会与x轴重合，那么再旋转z轴就没有任何的意义了，永远不会发生滚转。 Quaternion RotationComplex在我们学习四元数之前，我们先来了解一下四元数的起源–复数。复数系统引入了一个新的集合–虚数，其实为了解决一些特定无解的方程：$$\begin{equation}x^{2} + 1 = 0\end{equation}$$任意实数的平方都是非负数，为了求解上面的方程一个新的术语就发明了，他就是虚数：$$i^{2} = -1$$复数的集合是一个实数和一个虚数的和：$$z = a + bi \quad a,b \in R, i^2 = -1\tag{9}$$复数有很多的数学概念，具体的请查详细资料，这里不再累述。 二维空间上的旋转你可能在数学中见过类似的模式，但是是以(x,y,-x,-y,x…)的形式，这是2D笛卡尔平面对一个点逆时针旋转$90^\circ$生成的；(x,-y,-x,y,x…)则是在2D笛卡尔平面对一个点顺时针$90^\circ$生成的。 我们也能够把复数映射到一个2D网格平面–复数平面，只需要将实数映射到横轴、虚数映射到纵轴即可： 现在我们随机在复数平面上取一个点：$$p = 2 + i$$q,r,s,t分别是每次递乘i的结果：$$\begin{align}q&amp;=-1+2i \\r&amp;=-2-i \\s&amp;=1-2i \\t&amp;=2+i \\\end{align}$$ 所以我们可以在复数平面上进行任意角度的旋转：$$\begin{equation}q=cos\theta + isin\theta\tag{10}\end{equation}$$ Quaternion Theory了解了复数系统和复数平面后，我们可以额外增加2个虚数到我们的复数系统，从而把这些概念扩展到3维空间。四元数的一般形式：$$\begin{equation}q=s+xi+yj+zk \quad s,x,y,z \in R\tag{11}\end{equation}$$其中有如下性质：$$i^{2}=j^{2}=k^{2}=ijk=-1$$以及与笛卡尔坐标系下单位向量叉积规则很类似的等式：$$ij=k \quad jk=i \quad ki=j$$ 有序数的四元数我们可以用有序对的形式来表示四元数：$$\begin{equation}[s,v] \quad s \in R, v \in R^{3}\tag{12}\end{equation}$$使用这种表示法，我们可以更容易地展示四元数和复数之间的相似性。其二元形式可以表示为：$$q=s+v\tag{13}$$ 四元数的共轭四元数的共轭就是将虚向量取反：$$q^{-1} = s-v\tag{14}$$ 四元数的乘积四元数的乘积可以表示为：$$q_{1}q_{2}=s_{1}s_{2}-v_{1} \cdot v_{2}+s_{1}v_{2}+s_{2}v_{1}+v_{1} \times v_{2}\tag{15}$$对于四元数，还有很多的数学性质，有兴趣的话可以去查看相关的资料，这里不再累述。 四元数的旋转这里只参考3D游戏与计算机图形学中的数学方法一书并加上作者的看法来讲述四元数，这块的数学方法比较复杂，不做更深入的讨论 同态函数的证明三维空间的旋转可以看成函数在三维向量空间内的映射变换。这个函数表示的是一个旋转变换$\phi$，必须保持长度、角度和偏手性不变。如果下式成立，则函数$\phi$可以保持旋转向量的长度不变性。$$||\phi(P)||=||P||\tag{16}$$对于三维空间中的点：$P_1$和$P_2$，连接坐标系原点与这两个点的线段之间的夹角如果满足以下条件，在旋转过程中可保持不变(对两个向量做同一变换不应改变向量之间的夹角)：$$\begin{equation}\phi(P_{1}) \cdot \phi(P_{2}) = P_{1} \cdot P_{2}\tag{17}\end{equation}$$我们对向量的点积使用$\phi$，那么也应该保证旋转长度不变性：$$\phi(P_{1}) \cdot \phi(P_{2}) = P_{1} \cdot P_{2} = \phi(P_{1} \cdot P_{2})\tag{18}$$同理旋转过程中偏手性也不应该改变：$$\phi(P_{1}) \times \phi(P_{2}) = \phi(P_{2} \times P_{2})\tag{19}$$我们将$P_1$和$P_2$看作是标量为0的四元数，结合上面的可得：$$P_{1}P_{2}=-P_{1} \cdot P_{2} + P_{1} \times P_{2}$$结合上面的公式，我们可以得倒：$$\begin{align}&amp;\phi(P_{1}P_{2}) = -\phi(P_{1} \cdot P_{2}) + \phi(P_{1} \times P_{2}) \\&amp;\phi(P_{1}P_{2}) = -\phi(P_{1}) \cdot \phi(P_{2}) + \phi(P_{1}) \times \phi(P_{2}) \\end{align}$$这里$\phi(P_{1})$和$\phi(P_{2})$表示的是经过旋转变换后的四元数，那么上面式子的右式就可以写成 $\phi(P_{1})\phi(P_{2})$。则有：$$\phi(P_{1}P_{2}) = \phi(P_{1})\phi(P_{2})\tag{20}$$满足此式的函数称为同态函数，保证了角度不变性和偏手性不变性的条件。 旋转公式的推导同态函数有一个很重要的性质： &emsp;&emsp;给定一个G集合中的元素g，有变换$\gamma_{g}=gxg^{-1}$将其变化到，$\gamma_{g}:G \to G$这时是同$\gamma_{g}$态的。$$\begin{equation}\gamma_{g}(x)\gamma_{g}(y)=(gxg^{-1})(gyg^{-1})=gxg^{-1}gyg^{-1}=gxyg^{-1}=\gamma_{g}(xy)\tag{21}\end{equation}$$同态函数要保证$\gamma_{g}$经过$\gamma_{g^{-1}}$样一个逆变换后可以变换回原本的元素g，那么我们有：$$\begin{equation}\gamma_{g^{-1}}(\gamma_{g}(x))=\gamma_{g^{-1}}(gxg^{-1})=g^{-1}(gxg^{-1})g=g^{-1}gxg^{-1}g=x\end{equation}$$对于任意的$x \in G$，与$\gamma_{g^{-1}}$和可逆$\gamma_{g}$且互为逆变换。 四元数的旋转现在我们设q为非0的四元数，表示旋转变换函数的集合，有：$$\phi_{q}(P)=qPq^{-1}\tag{22}$$令$q=s+v​$为一个单位四元数，则$q^{-1}=s-v​$，对于三维空间中的点P(相当于一个实数项为0的四元数，方便使用四元数的乘积)，有：$$\begin{align}qPq^{-1}&amp;=(s+v)P(s-v) \\&amp;=(-v \cdot P + sP + v \times P)(s-v) \\&amp;=s^{2}P + 2sv \times P + (v \cdot P)v - v \times P \times v\end{align}$$因为$v \times P \times V=v^2P-(v \cdot P)P$，所以可化简为：$$qPq^{-1}=(s^2-v^2)P+2sv \times P + 2(v \cdot P)v$$令$v=s\overrightarrow{A}$，其中$\overrightarrow{A}$为单位向量：$$qPq^{-1}=(s^{2}-v^{2})P + 2stA \times P + 2t^{2}(A \cdot P)A$$与之前绕任意轴旋转的旋转公式相比，可得：$$\begin{align}&amp;s^2 - t^2 = cos\theta \\&amp;2st = sin\theta \\&amp;2t^2 = 1 - cos\theta\end{align}$$可得：$$t=sin\frac{\theta}{2}$$可得绕轴$\overrightarrow{A}$旋转$\theta$角对应的单位四元数$\overrightarrow{q}$的表达式为：$$q=cos\frac{\theta}{2} + Asin\frac{\theta}{2}\tag{23}$$我们知道，计算两个四元数的乘积只需要16次乘-加运算，而计算两个$3 \times 3$矩阵的乘积需要27次这样的运算。因此对一个向量做多次旋转操作时，使用四元数进行变换可以提高计算效率。 在实际编程中，我们经常要将四元数变成与其等效的$3 \times 3$矩阵，其中具体的数学推到比较复杂，可以参考3D游戏与计算机图形学中的数学方法，我们这里不再累述。在代码中，我们可以使用GLM轻松地将四元数旋转转化为对应的旋转矩阵： 1mat4 model = glm::mat4_cast(q); 四元数还有一篇比较经典的文章可供参考。另外，有一个重要的球型线性插值没有介绍，未来在human-motion的实践中再进行补充。 Quaternion Camera Appendix &amp; Reference推荐文章（由hexo文章推荐插件驱动）OpenGL Pipeline]]></content>
      <tags>
        <tag>Computer Graphics</tag>
      </tags>
  </entry>
</search>
